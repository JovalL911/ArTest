<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>A-Frame AR â€” Floor Place Rectangle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script>
      async function checkARSupport() {
        try {
          if (!('xr' in navigator) || typeof navigator.xr.isSessionSupported !== 'function') {
            return false;
          }

          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          return Boolean(supported);
        } catch (error) {
          console.warn('AR support check failed', error);
          return false;
        }
      }

      const HINT_MESSAGES = {
        start:
          'AR gestartet â€“ suche eine ebene, gut beleuchtete FlÃ¤che. Bewege das GerÃ¤t langsam in einer â€ž8â€œ, bis ein blaues Ziel auftaucht.',
        keepScanning:
          'Scanne weiterâ€¦ halte die Kamera auf eine strukturierte FlÃ¤che (Tisch, Boden) gerichtet und bewege dich leicht, bis das Ziel erscheint.',
        promptStart: 'AR noch nicht aktiv â€“ tippe unten rechts auf â€žARâ€œ, um zu starten.',
        rescan: 'Neuscan gestartetâ€¦ suche erneut nach einer ebenen FlÃ¤che.',
        rescanFail:
          'Keine neue FlÃ¤che gefunden. Bewege die Kamera leicht und stelle sicher, dass der Bereich gut beleuchtet ist.',
        found:
          'FlÃ¤che erkannt âœ… Tippe auf den Bildschirm, um die Karte dort abzulegen.',
        foundRescan:
          'Neuscan erfolgreich âœ… Tippe auf den Bildschirm, um die Karte neu zu platzieren.',
        placed:
          'Karte platziert ðŸŽ‰ Die FlÃ¤che bleibt verankert, bewege die Kamera ruhig weiter.',
        unavailable: 'Hit-Test nicht verfÃ¼gbar auf diesem GerÃ¤t/Browser. PrÃ¼fe WebXR- und Kamera-Support.',
        error:
          'Hit-Test Fehler. Erlaube Kamera- und Bewegungssensoren und stelle ausreichende Beleuchtung sicher.',
        idle: 'Tippe unten rechts auf â€žARâ€œ, um die Kamera zu starten.'
      };

      AFRAME.registerComponent('ar-hints', {
        init() {
          this.hintEl = document.getElementById('hint');
          this.reticle = document.getElementById('reticle');
          this.card = document.getElementById('card');
          this.hitStatusBar = document.getElementById('hitStatusBar');
          this.hitStatusEl = document.getElementById('hitStatus');
          this.hitDebug = document.getElementById('hitDebug');
          this.hitDebugStateEl = document.getElementById('hitDebugState');
          this.scene = this.el.sceneEl;
          this.scanInterval = null;
          this.rescanTimeout = null;
          this.rescanPending = false;

          this.events = {
            'enter-vr': this.onEnterVR.bind(this),
            'ar-hit-test-start': this.onHitTestStart.bind(this),
            'ar-hit-test-achieved': this.onHitTestAchieved.bind(this),
            'ar-hit-test-select': this.onHitTestSelect.bind(this),
            'ar-hit-test-unavailable': this.onHitTestUnavailable.bind(this),
            'ar-hit-test-error': this.onHitTestError.bind(this),
            'exit-vr': this.onExitVR.bind(this)
          };

          Object.entries(this.events).forEach(([event, handler]) => {
            this.scene.addEventListener(event, handler);
          });
          this.onDoubleClick = this.onDoubleClick.bind(this);
          document.addEventListener('dblclick', this.onDoubleClick);

          this.setHitDebugState(false);
        },

        remove() {
          Object.entries(this.events).forEach(([event, handler]) => {
            this.scene.removeEventListener(event, handler);
          });
          document.removeEventListener('dblclick', this.onDoubleClick);
        },

        updateHint(text, show = true) {
          if (!this.hintEl) return;
          this.hintEl.textContent = text;
          this.hintEl.style.display = show ? 'block' : 'none';
        },

        updateHitStatus(text, show = true) {
          if (!this.hitStatusEl || !this.hitStatusBar) return;
          this.hitStatusEl.textContent = text;
          this.hitStatusBar.style.display = show ? 'flex' : 'none';
          this.hitStatusEl.style.display = show ? 'flex' : 'none';
        },

        setHitDebugState(detected) {
          if (!this.hitDebugStateEl || !this.hitDebug) return;

          // Always show the debug bar when this is called
          this.hitDebug.style.display = 'block';
          this.hitDebugStateEl.style.fontWeight = '700';

          if (detected) {
            this.hitDebugStateEl.textContent = 'detected';
            this.hitDebugStateEl.style.color = '#22c55e'; // green
          } else {
            this.hitDebugStateEl.textContent = 'not detected yet';
            this.hitDebugStateEl.style.color = '#ef4444'; // red
          }
        },

        startScanningHint() {
          this.stopScanningHint();
          this.updateHint(HINT_MESSAGES.start);
          this.scanInterval = setInterval(() => {
            this.updateHint(HINT_MESSAGES.keepScanning);
          }, 4500);
        },

        stopScanningHint() {
          if (this.scanInterval) {
            clearInterval(this.scanInterval);
            this.scanInterval = null;
          }
          if (this.rescanTimeout) {
            clearTimeout(this.rescanTimeout);
            this.rescanTimeout = null;
          }
          this.rescanPending = false;
        },

        toggleReticle(visible) {
          if (this.reticle) {
            this.reticle.setAttribute('visible', visible);
          }
        },

        onEnterVR() {
          this.startScanningHint();
          this.toggleReticle(false);
          this.updateHitStatus('nichts gefunden');
          this.setHitDebugState(false);
        },

        onDoubleClick() {
          if (!this.el.sceneEl.is('vr-mode')) {
            this.updateHint(HINT_MESSAGES.promptStart);
            return;
          }

          this.restartScan();
        },

        restartScan() {
          this.rescanPending = true;
          this.toggleReticle(false);
          this.resetPlacement();
          this.startScanningHint();
          this.updateHint(HINT_MESSAGES.rescan);
          this.updateHitStatus('nichts gefunden');
          this.setHitDebugState(false);

          this.scene.emit('ar-hit-test-start');

          this.rescanTimeout = setTimeout(() => {
            if (!this.rescanPending) return;
            this.updateHint(HINT_MESSAGES.rescanFail);
            this.rescanPending = false;
          }, 8000);
        },

        resetPlacement() {
          if (!this.card) return;
          this.card.setAttribute('visible', false);

          const placeOnce = this.card.components['place-once'];
          if (placeOnce) {
            placeOnce.placed = false;
          }
        },

        onHitTestStart() {
          this.startScanningHint();
          this.toggleReticle(false);
          this.updateHitStatus('nichts gefunden');
          this.setHitDebugState(false);
        },

        onHitTestAchieved() {
          this.stopScanningHint();
          const message = this.rescanPending
            ? HINT_MESSAGES.foundRescan
            : HINT_MESSAGES.found;
          this.updateHint(message);
          this.rescanPending = false;
          this.toggleReticle(true);
          this.updateHitStatus('YES, hab etwas.');
          this.setHitDebugState(true);
        },

        onHitTestSelect() {
          this.stopScanningHint();
          this.updateHint(HINT_MESSAGES.placed);
          this.toggleReticle(false);
          this.updateHitStatus('YES, hab etwas.');
          this.setHitDebugState(true);
        },

        onHitTestUnavailable() {
          this.stopScanningHint();
          this.updateHint(HINT_MESSAGES.unavailable);
          this.toggleReticle(false);
          this.updateHitStatus('nichts gefunden');
          this.setHitDebugState(false);
        },

        onHitTestError() {
          this.stopScanningHint();
          this.updateHint(HINT_MESSAGES.error);
          this.toggleReticle(false);
          this.updateHitStatus('nichts gefunden');
          this.setHitDebugState(false);
        },

        onExitVR() {
          this.stopScanningHint();
          this.toggleReticle(false);
          this.updateHint(HINT_MESSAGES.idle, false);
          this.updateHitStatus('nichts gefunden', false);
          this.setHitDebugState(false);

          if (this.hitDebug) {
            this.hitDebug.style.display = 'none';
          }
        }
      });

      /**
       * place-once
       * - Wartet auf das erste ar-hit-test-select Event (Tap in AR)
       * - Setzt die Karte auf die Position des Reticles
       * - Schaltet den Hit-Test danach ab (Objekt bleibt "verankert")
       */
      AFRAME.registerComponent('place-once', {
        schema: { reticle: { type: 'selector' } },

        init() {
          this.placed = false;
          this.onSelect = this.onSelect.bind(this);
          this.el.sceneEl.addEventListener('ar-hit-test-select', this.onSelect);
        },

        remove() {
          this.el.sceneEl.removeEventListener('ar-hit-test-select', this.onSelect);
        },

        onSelect() {
          const reticle = this.data.reticle;
          if (this.placed || !reticle || !reticle.object3D.visible) return;

          // Position und Rotation der Karte auf die des Reticles setzen
          this.el.object3D.position.copy(reticle.object3D.position);
          this.el.object3D.quaternion.copy(reticle.object3D.quaternion);
          this.el.setAttribute('visible', true);

          this.placed = true;
          reticle.setAttribute('visible', false);
        }
      });

      /**
       * ar-debug
       * - Protokolliert wichtige AR- und Hit-Test-Ereignisse
       * - Schreibt in die Konsole und in das Debug-Panel unten links
       */
      AFRAME.registerComponent('ar-debug', {
        init() {
          this.statusEl = document.getElementById('status');
          this.statusLog = document.getElementById('statusLog');
          this.log('Scene initialized, waiting for AR sessionâ€¦');

          const scene = this.el.sceneEl;
          const events = [
            ['enter-vr', 'XR session started'],
            ['exit-vr', 'XR session ended'],
            ['ar-hit-test-start', 'Hit-test started'],
            ['ar-hit-test-achieved', 'Surface found'],
            ['ar-hit-test-select', 'Placement tap received'],
            ['ar-hit-test-error', 'Hit-test error: check console'],
            ['ar-hit-test-unavailable', 'Hit-test unavailable on device'],
          ];
          events.forEach(([event, message]) => {
            scene.addEventListener(event, () => this.log(message));
          });
        },

        timestamp() {
          return new Date().toLocaleTimeString();
        },

        appendLog(message) {
          if (!this.statusLog) return;

          const entry = document.createElement('li');
          entry.textContent = `${this.timestamp()} â€” ${message}`;
          this.statusLog.appendChild(entry);

          while (this.statusLog.children.length > 8) {
            this.statusLog.removeChild(this.statusLog.firstChild);
          }
        },

        log(message) {
          console.info(`[AR DEBUG] ${message}`);
          if (this.statusEl) {
            this.statusEl.textContent = `${this.timestamp()} â€” ${message}`;
          }

          this.appendLog(message);
        }
      });

      document.addEventListener('DOMContentLoaded', () => {
        const hintEl = document.getElementById('hint');
        const scene = document.querySelector('a-scene');

        checkARSupport().then((supported) => {
          if (supported) return;

          if (hintEl) {
            hintEl.textContent =
              'AR / WebXR Hit-Test wird auf diesem GerÃ¤t/Browser nicht unterstÃ¼tzt.';
          }

          let attempts = 0;
          const disableXRButton = () => {
            const xrButtons = document.querySelectorAll('.a-enter-vr, .a-enter-ar');
            if (!xrButtons.length && attempts < 120) {
              attempts += 1;
              requestAnimationFrame(disableXRButton);
              return;
            }

            xrButtons.forEach((btn) => {
              btn.style.display = 'none';
              btn.setAttribute('disabled', 'true');
            });
          };

          disableXRButton();

          if (scene) {
            scene.setAttribute('xr-mode-ui', 'XRMode: ar; enterAREnabled: false');
          }
        });
      });
    </script>

    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background: #0b1724;
        color: #e2e8f0;
      }

      #hitDebug {
        position: fixed;
        top: 8px;
        left: 0;
        right: 0;
        display: block;
        text-align: center;
        font-size: 14px;
        pointer-events: none;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
      }

      #hitDebugState {
        font-weight: 700;
        color: #ef4444;
      }

      /* Overlay oben fÃ¼r kompaktes Hit-Test-Feedback */
      #hitStatusBar {
        position: fixed;
        top: 40px;
        left: 0;
        right: 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        pointer-events: none;
      }

      #hitStatusHint {
        color: #ff6961;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
      }

      #hitStatus {
        background: rgba(11, 23, 36, 0.8);
        color: #e2e8f0;
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        letter-spacing: 0.02em;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      /* DOM-Overlay fÃ¼r Text-Hinweise */
      #overlayUI {
        position: fixed;
        inset: 0;
        pointer-events: none;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding: 16px;
      }

      #hint {
        pointer-events: none;
        background: rgba(0, 0, 0, 0.55);
        color: #fff;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        backdrop-filter: blur(6px);
        max-width: min(480px, 90vw);
        text-align: center;
        line-height: 1.45;
      }

      #debugPanel {
        position: fixed;
        left: 12px;
        bottom: 12px;
        background: rgba(0, 0, 0, 0.65);
        color: #e2e8f0;
        padding: 10px 12px;
        border-radius: 10px;
        font-size: 12px;
        max-width: 320px;
        line-height: 1.4;
        pointer-events: none;
        backdrop-filter: blur(6px);
      }

      #statusLog {
        margin: 8px 0 0;
        padding-left: 16px;
        max-height: 160px;
        overflow: auto;
      }

      #statusLog li {
        margin-bottom: 4px;
      }
    </style>
  </head>
  <body>
    <div id="overlayUI" aria-live="polite">
      <div id="hitDebug">
        Hit detection: <span id="hitDebugState">not detected yet</span>
      </div>

      <div id="hitStatusBar" aria-live="polite">
        <div id="hitStatusHint">Scanne weiterâ€¦ halte die Kamera auf eine strukturierte FlÃ¤che.</div>
        <div id="hitStatus">nichts gefunden</div>
      </div>

      <div id="hint">
        Tippe unten rechts auf â€žARâ€œ, um die Kamera zu starten.
      </div>
    </div>

    <div id="debugPanel">
      <strong>AR Status:</strong>
      <div id="status">Scene initialized</div>
      <ul id="statusLog"></ul>
    </div>

    <!--
      A-Frame AR Szene
      - webxr: aktiviert AR-Modus + Hit-Test + DOM Overlay
      - xr-mode-ui: zeigt explizit nur den AR-Button an
      - ar-hit-test: aktualisiert das Reticle (target:#reticle) bei erkannter FlÃ¤che
      - cursor + raycaster: erlauben Screen-Tap-Interaktion mit .clickable
    -->
    <a-scene
      renderer="colorManagement: true; physicallyCorrectLights: true"
      webxr="mode: ar;
             referenceSpaceType: local;
             requiredFeatures: hit-test;
             optionalFeatures: dom-overlay;
             overlayElement: #overlayUI"
      xr-mode-ui="XRMode: ar; enterAREnabled: true"
      ar-hit-test="target: #reticle; type: transient"
      cursor="rayOrigin: mouse"
      raycaster="objects: .clickable" 
      ar-hints
      ar-debug>

      <!-- Beleuchtung (wirkt auf dein virtuelles UI-Panel) -->
      <a-entity light="type: hemisphere; intensity: 0.8; groundColor: #777"></a-entity>
      <a-entity light="type: directional; intensity: 0.6" position="0 3 1"></a-entity>

      <!-- Kamera in AR (keine Controls nÃ¶tig, die Pose kommt von WebXR) -->
      <a-entity camera look-controls="enabled: false"></a-entity>

      <!-- Reticle, das vom ar-hit-test Component positioniert wird -->
      <a-entity id="reticle" visible="false">
        <a-ring
          radius-inner="0.45"
          radius-outer="0.50"
          rotation="-90 0 0"
          material="color: #00bcd4; opacity: 0.95">
        </a-ring>

        <a-cylinder
          height="0.01"
          radius="0.40"
          rotation="-90 0 0"
          material="color: #00bcd4; opacity: 0.35">
        </a-cylinder>
      </a-entity>

      <!-- Deine "Karte" als leichtes UI-Panel -->
      <a-entity
        id="card"
        class="clickable"
        visible="false"
        geometry="primitive: plane; width: 0.55; height: 0.32"
        material="color: #0ea5e9; opacity: 0.92; roughness: 0.35; metalness: 0.1"
        text="value: AR Surface Demo; align: center; width: 1.5; color: #e0f2fe; wrapCount: 18"
        position="0 -10 0"
        place-once="reticle: #reticle">
        <a-entity
          geometry="primitive: plane; width: 0.5; height: 0.28"
          material="color: #020617; opacity: 0.6"
          position="0 0 0.001">
        </a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
